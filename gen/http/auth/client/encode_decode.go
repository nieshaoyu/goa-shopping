// Code generated by goa v3.1.1, DO NOT EDIT.
//
// auth HTTP client encoders and decoders
//
// Command:
// $ goa gen goa-shopping/design

package client

import (
	"bytes"
	"context"
	auth "goa-shopping/gen/auth"
	authviews "goa-shopping/gen/auth/views"
	"io/ioutil"
	"net/http"
	"net/url"

	goahttp "goa.design/goa/v3/http"
)

// BuildLoginRequest instantiates a HTTP request object with method and path
// set to call the "auth" service "Login" endpoint
func (c *Client) BuildLoginRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: LoginAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "Login", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeLoginRequest returns an encoder for requests sent to the auth Login
// server.
func EncodeLoginRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*auth.LoginPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "Login", "*auth.LoginPayload", v)
		}
		body := NewLoginRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "Login", err)
		}
		return nil
	}
}

// DecodeLoginResponse returns a decoder for responses returned by the auth
// Login endpoint. restoreBody controls whether the response body should be
// restored after having been read.
func DecodeLoginResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body LoginResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "Login", err)
			}
			err = ValidateLoginResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "Login", err)
			}
			res := NewLoginResultOK(&body)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "Login", resp.StatusCode, string(body))
		}
	}
}

// BuildGetUserInfoRequest instantiates a HTTP request object with method and
// path set to call the "auth" service "GetUserInfo" endpoint
func (c *Client) BuildGetUserInfoRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetUserInfoAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "GetUserInfo", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetUserInfoRequest returns an encoder for requests sent to the auth
// GetUserInfo server.
func EncodeGetUserInfoRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*auth.GetUserInfoPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "GetUserInfo", "*auth.GetUserInfoPayload", v)
		}
		if p.JWTToken != nil {
			head := *p.JWTToken
			req.Header.Set("Authorization", head)
		}
		return nil
	}
}

// DecodeGetUserInfoResponse returns a decoder for responses returned by the
// auth GetUserInfo endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeGetUserInfoResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetUserInfoResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "GetUserInfo", err)
			}
			p := NewGetUserInfoUserInfoOK(&body)
			view := "default"
			vres := &authviews.UserInfo{Projected: p, View: view}
			if err = authviews.ValidateUserInfo(vres); err != nil {
				return nil, goahttp.ErrValidationError("auth", "GetUserInfo", err)
			}
			res := auth.NewUserInfo(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "GetUserInfo", resp.StatusCode, string(body))
		}
	}
}

// BuildSignUpRequest instantiates a HTTP request object with method and path
// set to call the "auth" service "SignUp" endpoint
func (c *Client) BuildSignUpRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SignUpAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "SignUp", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeSignUpRequest returns an encoder for requests sent to the auth SignUp
// server.
func EncodeSignUpRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*auth.SignUpPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "SignUp", "*auth.SignUpPayload", v)
		}
		body := NewSignUpRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "SignUp", err)
		}
		return nil
	}
}

// DecodeSignUpResponse returns a decoder for responses returned by the auth
// SignUp endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeSignUpResponse may return the following errors:
//	- "bad_request" (type *goa.ServiceError): http.StatusBadRequest
//	- error: internal error
func DecodeSignUpResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body SignUpResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "SignUp", err)
			}
			p := NewSignUpSessionOK(&body)
			view := "default"
			vres := &authviews.Session{Projected: p, View: view}
			if err = authviews.ValidateSession(vres); err != nil {
				return nil, goahttp.ErrValidationError("auth", "SignUp", err)
			}
			res := auth.NewSession(vres)
			return res, nil
		case http.StatusBadRequest:
			var (
				body SignUpBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "SignUp", err)
			}
			err = ValidateSignUpBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("auth", "SignUp", err)
			}
			return nil, NewSignUpBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "SignUp", resp.StatusCode, string(body))
		}
	}
}

// BuildSetPasswordRequest instantiates a HTTP request object with method and
// path set to call the "auth" service "SetPassword" endpoint
func (c *Client) BuildSetPasswordRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SetPasswordAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "SetPassword", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeSetPasswordRequest returns an encoder for requests sent to the auth
// SetPassword server.
func EncodeSetPasswordRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*auth.SetPasswordPayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "SetPassword", "*auth.SetPasswordPayload", v)
		}
		body := NewSetPasswordRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "SetPassword", err)
		}
		return nil
	}
}

// DecodeSetPasswordResponse returns a decoder for responses returned by the
// auth SetPassword endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeSetPasswordResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body SetPasswordResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "SetPassword", err)
			}
			p := NewSetPasswordSuccessOK(&body)
			view := "default"
			vres := &authviews.Success{Projected: p, View: view}
			if err = authviews.ValidateSuccess(vres); err != nil {
				return nil, goahttp.ErrValidationError("auth", "SetPassword", err)
			}
			res := auth.NewSuccess(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "SetPassword", resp.StatusCode, string(body))
		}
	}
}

// BuildRequestEmailCodeRequest instantiates a HTTP request object with method
// and path set to call the "auth" service "RequestEmailCode" endpoint
func (c *Client) BuildRequestEmailCodeRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RequestEmailCodeAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "RequestEmailCode", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRequestEmailCodeRequest returns an encoder for requests sent to the
// auth RequestEmailCode server.
func EncodeRequestEmailCodeRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*auth.RequestEmailCodePayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "RequestEmailCode", "*auth.RequestEmailCodePayload", v)
		}
		body := NewRequestEmailCodeRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "RequestEmailCode", err)
		}
		return nil
	}
}

// DecodeRequestEmailCodeResponse returns a decoder for responses returned by
// the auth RequestEmailCode endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeRequestEmailCodeResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body RequestEmailCodeResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "RequestEmailCode", err)
			}
			p := NewRequestEmailCodeSuccessOK(&body)
			view := "default"
			vres := &authviews.Success{Projected: p, View: view}
			if err = authviews.ValidateSuccess(vres); err != nil {
				return nil, goahttp.ErrValidationError("auth", "RequestEmailCode", err)
			}
			res := auth.NewSuccess(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "RequestEmailCode", resp.StatusCode, string(body))
		}
	}
}

// BuildRequestSmSCodeRequest instantiates a HTTP request object with method
// and path set to call the "auth" service "RequestSmSCode" endpoint
func (c *Client) BuildRequestSmSCodeRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: RequestSmSCodeAuthPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("auth", "RequestSmSCode", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeRequestSmSCodeRequest returns an encoder for requests sent to the auth
// RequestSmSCode server.
func EncodeRequestSmSCodeRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*auth.RequestSmSCodePayload)
		if !ok {
			return goahttp.ErrInvalidType("auth", "RequestSmSCode", "*auth.RequestSmSCodePayload", v)
		}
		body := NewRequestSmSCodeRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("auth", "RequestSmSCode", err)
		}
		return nil
	}
}

// DecodeRequestSmSCodeResponse returns a decoder for responses returned by the
// auth RequestSmSCode endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeRequestSmSCodeResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body RequestSmSCodeResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("auth", "RequestSmSCode", err)
			}
			p := NewRequestSmSCodeSuccessOK(&body)
			view := "default"
			vres := &authviews.Success{Projected: p, View: view}
			if err = authviews.ValidateSuccess(vres); err != nil {
				return nil, goahttp.ErrValidationError("auth", "RequestSmSCode", err)
			}
			res := auth.NewSuccess(vres)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("auth", "RequestSmSCode", resp.StatusCode, string(body))
		}
	}
}

// unmarshalSessionResponseBodyToAuthSession builds a value of type
// *auth.Session from a value of type *SessionResponseBody.
func unmarshalSessionResponseBodyToAuthSession(v *SessionResponseBody) *auth.Session {
	if v == nil {
		return nil
	}
	res := &auth.Session{}
	res.User = unmarshalUserResponseBodyToAuthUser(v.User)
	res.Credentials = unmarshalCredentialsResponseBodyToAuthCredentials(v.Credentials)

	return res
}

// unmarshalUserResponseBodyToAuthUser builds a value of type *auth.User from a
// value of type *UserResponseBody.
func unmarshalUserResponseBodyToAuthUser(v *UserResponseBody) *auth.User {
	res := &auth.User{
		ID:        *v.ID,
		Username:  *v.Username,
		Nickname:  *v.Nickname,
		Mobile:    *v.Mobile,
		Email:     *v.Email,
		Type:      *v.Type,
		IsActive:  *v.IsActive,
		LoginTime: *v.LoginTime,
	}

	return res
}

// unmarshalCredentialsResponseBodyToAuthCredentials builds a value of type
// *auth.Credentials from a value of type *CredentialsResponseBody.
func unmarshalCredentialsResponseBodyToAuthCredentials(v *CredentialsResponseBody) *auth.Credentials {
	res := &auth.Credentials{
		Token:     *v.Token,
		ExpiresIn: *v.ExpiresIn,
	}

	return res
}

// unmarshalUserResponseBodyToAuthviewsUserView builds a value of type
// *authviews.UserView from a value of type *UserResponseBody.
func unmarshalUserResponseBodyToAuthviewsUserView(v *UserResponseBody) *authviews.UserView {
	if v == nil {
		return nil
	}
	res := &authviews.UserView{
		ID:        v.ID,
		Username:  v.Username,
		Nickname:  v.Nickname,
		Mobile:    v.Mobile,
		Email:     v.Email,
		Type:      v.Type,
		IsActive:  v.IsActive,
		LoginTime: v.LoginTime,
	}

	return res
}

// unmarshalCredentialsResponseBodyToAuthviewsCredentialsView builds a value of
// type *authviews.CredentialsView from a value of type
// *CredentialsResponseBody.
func unmarshalCredentialsResponseBodyToAuthviewsCredentialsView(v *CredentialsResponseBody) *authviews.CredentialsView {
	res := &authviews.CredentialsView{
		Token:     v.Token,
		ExpiresIn: v.ExpiresIn,
	}

	return res
}
