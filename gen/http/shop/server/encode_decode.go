// Code generated by goa v3.1.1, DO NOT EDIT.
//
// shop HTTP server encoders and decoders
//
// Command:
// $ goa gen goa-shopping/design

package server

import (
	"context"
	shop "goa-shopping/gen/shop"
	shopviews "goa-shopping/gen/shop/views"
	"io"
	"net/http"
	"strconv"
	"strings"
	"unicode/utf8"

	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeGoodsListResponse returns an encoder for responses returned by the
// shop GoodsList endpoint.
func EncodeGoodsListResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*shop.GoodsListResult)
		enc := encoder(ctx, w)
		body := NewGoodsListResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGoodsListRequest returns a decoder for requests sent to the shop
// GoodsList endpoint.
func DecodeGoodsListRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			cursor   int
			limit    int
			jwtToken *string
			err      error
		)
		{
			cursorRaw := r.URL.Query().Get("cursor")
			if cursorRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("cursor", "query string"))
			}
			v, err2 := strconv.ParseInt(cursorRaw, 10, strconv.IntSize)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("cursor", cursorRaw, "integer"))
			}
			cursor = int(v)
		}
		{
			limitRaw := r.URL.Query().Get("limit")
			if limitRaw == "" {
				err = goa.MergeErrors(err, goa.MissingFieldError("limit", "query string"))
			}
			v, err2 := strconv.ParseInt(limitRaw, 10, strconv.IntSize)
			if err2 != nil {
				err = goa.MergeErrors(err, goa.InvalidFieldTypeError("limit", limitRaw, "integer"))
			}
			limit = int(v)
		}
		jwtTokenRaw := r.Header.Get("Authorization")
		if jwtTokenRaw != "" {
			jwtToken = &jwtTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGoodsListPayload(cursor, limit, jwtToken)
		if payload.JWTToken != nil {
			if strings.Contains(*payload.JWTToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.JWTToken, " ", 2)[1]
				payload.JWTToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGoodsListError returns an encoder for errors returned by the GoodsList
// shop endpoint.
func EncodeGoodsListError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGoodsListInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGoodsListBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetGoodsResponse returns an encoder for responses returned by the shop
// GetGoods endpoint.
func EncodeGetGoodsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*shopviews.GoodsSpu)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewGetGoodsResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetGoodsRequest returns a decoder for requests sent to the shop
// GetGoods endpoint.
func DecodeGetGoodsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			goodsID  string
			jwtToken string
			err      error

			params = mux.Vars(r)
		)
		goodsID = params["goodsId"]
		if utf8.RuneCountInString(goodsID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("goodsID", goodsID, utf8.RuneCountInString(goodsID), 1, true))
		}
		jwtToken = r.Header.Get("Authorization")
		if jwtToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetGoodsPayload(goodsID, jwtToken)
		if strings.Contains(payload.JWTToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.JWTToken, " ", 2)[1]
			payload.JWTToken = cred
		}

		return payload, nil
	}
}

// EncodeGetGoodsError returns an encoder for errors returned by the GetGoods
// shop endpoint.
func EncodeGetGoodsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetGoodsInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewGetGoodsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateGoodsResponse returns an encoder for responses returned by the
// shop UpdateGoods endpoint.
func EncodeUpdateGoodsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, interface{}) error {
	return func(ctx context.Context, w http.ResponseWriter, v interface{}) error {
		res := v.(*shopviews.GoodsSpu)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "application/json")
		enc := encoder(ctx, w)
		body := NewUpdateGoodsResponseBody(res.Projected)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateGoodsRequest returns a decoder for requests sent to the shop
// UpdateGoods endpoint.
func DecodeUpdateGoodsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (interface{}, error) {
	return func(r *http.Request) (interface{}, error) {
		var (
			body UpdateGoodsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateGoodsRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			goodsID  string
			jwtToken string

			params = mux.Vars(r)
		)
		goodsID = params["goodsId"]
		if utf8.RuneCountInString(goodsID) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("goodsID", goodsID, utf8.RuneCountInString(goodsID), 1, true))
		}
		jwtToken = r.Header.Get("Authorization")
		if jwtToken == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("Authorization", "header"))
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateGoodsPayload(&body, goodsID, jwtToken)
		if strings.Contains(payload.JWTToken, " ") {
			// Remove authorization scheme prefix (e.g. "Bearer")
			cred := strings.SplitN(payload.JWTToken, " ", 2)[1]
			payload.JWTToken = cred
		}

		return payload, nil
	}
}

// EncodeUpdateGoodsError returns an encoder for errors returned by the
// UpdateGoods shop endpoint.
func EncodeUpdateGoodsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		en, ok := v.(ErrorNamer)
		if !ok {
			return encodeError(ctx, w, v)
		}
		switch en.ErrorName() {
		case "internal_server_error":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateGoodsInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", "internal_server_error")
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "bad_request":
			res := v.(*goa.ServiceError)
			enc := encoder(ctx, w)
			var body interface{}
			if formatter != nil {
				body = formatter(res)
			} else {
				body = NewUpdateGoodsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", "bad_request")
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// marshalShopGoodsToGoodsResponseBody builds a value of type
// *GoodsResponseBody from a value of type *shop.Goods.
func marshalShopGoodsToGoodsResponseBody(v *shop.Goods) *GoodsResponseBody {
	res := &GoodsResponseBody{
		Errcode: v.Errcode,
		Errmsg:  v.Errmsg,
	}
	if v.Data != nil {
		res.Data = make([]*GoodsSpuResponseBody, len(v.Data))
		for i, val := range v.Data {
			res.Data[i] = marshalShopGoodsSpuToGoodsSpuResponseBody(val)
		}
	}

	return res
}

// marshalShopGoodsSpuToGoodsSpuResponseBody builds a value of type
// *GoodsSpuResponseBody from a value of type *shop.GoodsSpu.
func marshalShopGoodsSpuToGoodsSpuResponseBody(v *shop.GoodsSpu) *GoodsSpuResponseBody {
	res := &GoodsSpuResponseBody{
		ID:          v.ID,
		Name:        v.Name,
		Description: v.Description,
	}
	if v.GoodsType != nil {
		res.GoodsType = marshalShopGoodsTypeToGoodsTypeResponseBody(v.GoodsType)
	}
	if v.GoodsBrand != nil {
		res.GoodsBrand = marshalShopGoodsBrandToGoodsBrandResponseBody(v.GoodsBrand)
	}
	if v.GoodsSku != nil {
		res.GoodsSku = make([]*GoodsSkuResponseBody, len(v.GoodsSku))
		for i, val := range v.GoodsSku {
			res.GoodsSku[i] = marshalShopGoodsSkuToGoodsSkuResponseBody(val)
		}
	}

	return res
}

// marshalShopGoodsTypeToGoodsTypeResponseBody builds a value of type
// *GoodsTypeResponseBody from a value of type *shop.GoodsType.
func marshalShopGoodsTypeToGoodsTypeResponseBody(v *shop.GoodsType) *GoodsTypeResponseBody {
	res := &GoodsTypeResponseBody{
		ID:          v.ID,
		Name:        v.Name,
		Description: v.Description,
	}

	return res
}

// marshalShopGoodsBrandToGoodsBrandResponseBody builds a value of type
// *GoodsBrandResponseBody from a value of type *shop.GoodsBrand.
func marshalShopGoodsBrandToGoodsBrandResponseBody(v *shop.GoodsBrand) *GoodsBrandResponseBody {
	res := &GoodsBrandResponseBody{
		ID:          v.ID,
		Name:        v.Name,
		Description: v.Description,
	}

	return res
}

// marshalShopGoodsSkuToGoodsSkuResponseBody builds a value of type
// *GoodsSkuResponseBody from a value of type *shop.GoodsSku.
func marshalShopGoodsSkuToGoodsSkuResponseBody(v *shop.GoodsSku) *GoodsSkuResponseBody {
	if v == nil {
		return nil
	}
	res := &GoodsSkuResponseBody{
		ID:   v.ID,
		Name: v.Name,
	}
	if v.GoodsSkuValue != nil {
		res.GoodsSkuValue = make([]*GoodsSkuValueResponseBody, len(v.GoodsSkuValue))
		for i, val := range v.GoodsSkuValue {
			res.GoodsSkuValue[i] = marshalShopGoodsSkuValueToGoodsSkuValueResponseBody(val)
		}
	}

	return res
}

// marshalShopGoodsSkuValueToGoodsSkuValueResponseBody builds a value of type
// *GoodsSkuValueResponseBody from a value of type *shop.GoodsSkuValue.
func marshalShopGoodsSkuValueToGoodsSkuValueResponseBody(v *shop.GoodsSkuValue) *GoodsSkuValueResponseBody {
	if v == nil {
		return nil
	}
	res := &GoodsSkuValueResponseBody{
		ID:   v.ID,
		Name: v.Name,
	}

	return res
}

// marshalShopviewsGoodsTypeViewToGoodsTypeResponseBody builds a value of type
// *GoodsTypeResponseBody from a value of type *shopviews.GoodsTypeView.
func marshalShopviewsGoodsTypeViewToGoodsTypeResponseBody(v *shopviews.GoodsTypeView) *GoodsTypeResponseBody {
	res := &GoodsTypeResponseBody{
		ID:          *v.ID,
		Name:        *v.Name,
		Description: *v.Description,
	}

	return res
}

// marshalShopviewsGoodsBrandViewToGoodsBrandResponseBody builds a value of
// type *GoodsBrandResponseBody from a value of type *shopviews.GoodsBrandView.
func marshalShopviewsGoodsBrandViewToGoodsBrandResponseBody(v *shopviews.GoodsBrandView) *GoodsBrandResponseBody {
	res := &GoodsBrandResponseBody{
		ID:          *v.ID,
		Name:        *v.Name,
		Description: *v.Description,
	}

	return res
}

// marshalShopviewsGoodsSkuViewToGoodsSkuResponseBody builds a value of type
// *GoodsSkuResponseBody from a value of type *shopviews.GoodsSkuView.
func marshalShopviewsGoodsSkuViewToGoodsSkuResponseBody(v *shopviews.GoodsSkuView) *GoodsSkuResponseBody {
	if v == nil {
		return nil
	}
	res := &GoodsSkuResponseBody{
		ID:   *v.ID,
		Name: *v.Name,
	}
	if v.GoodsSkuValue != nil {
		res.GoodsSkuValue = make([]*GoodsSkuValueResponseBody, len(v.GoodsSkuValue))
		for i, val := range v.GoodsSkuValue {
			res.GoodsSkuValue[i] = marshalShopviewsGoodsSkuValueViewToGoodsSkuValueResponseBody(val)
		}
	}

	return res
}

// marshalShopviewsGoodsSkuValueViewToGoodsSkuValueResponseBody builds a value
// of type *GoodsSkuValueResponseBody from a value of type
// *shopviews.GoodsSkuValueView.
func marshalShopviewsGoodsSkuValueViewToGoodsSkuValueResponseBody(v *shopviews.GoodsSkuValueView) *GoodsSkuValueResponseBody {
	if v == nil {
		return nil
	}
	res := &GoodsSkuValueResponseBody{
		ID:   *v.ID,
		Name: *v.Name,
	}

	return res
}
